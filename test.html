<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TM → PCP Dominoes</title>
  <style>


    .app-footer {
      margin-top: 2rem;
      padding-top: 0.75rem;
      border-top: 1px solid var(--panel-border);
      font-size: 0.8rem;
      color: var(--small-note);
    }

    .app-footer a {
      color: inherit;
      text-decoration: underline;
    }

    .app-footer a:hover {
      text-decoration: none;
    }

    .footer-inner {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    @media (min-width: 700px) {
      .footer-inner {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }
    }


    .tm-summary {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-top: 0.5rem;
      margin-bottom: 0.75rem;
    }

    #tmInfo {
      flex: 1 1 260px;
    }

    #tmTable {
      flex: 1 1 260px;
      max-width: 100%;
      overflow-x: auto;
    }

    /* Transition table styling */
    .tm-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }

    .tm-table th,
    .tm-table td {
      border: 1px solid var(--panel-border);
      padding: 0.2rem 0.35rem;
      text-align: center;
    }

    .tm-table thead th {
      background: var(--panel-bg);
      position: sticky;
      top: 0;
    }

    .tm-state-cell {
      text-align: left;
      white-space: nowrap;
    }

    /* Optional: highlight init/accepting states a bit */
    .tm-state-cell-init {
      font-weight: 600;
    }

    .tm-state-cell-accept {
      color: #d97706;
    }
    body.dark-mode .tm-state-cell-accept {
      color: #fbbf24;
    }

    /* Make left (TM info) and right (table) align bottom inside tm-summary */
    .tm-summary {
      display: flex;
      flex-wrap: nowrap;
      align-items: flex-end; /* <--- bottom alignment */
      gap: 1rem;
    }

    /* Right panel containing label + table */
    #tmTableContainer {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      justify-content: flex-end; /* <--- push table to bottom */
    }

    /* Label above the table */
    #tmTableLabel {
      font-size: 0.85rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    /* Ensure long comments on the left do NOT stretch the height of the right panel */
    #tmInfo {
      flex: 1 1 auto;
      max-width: 50%;
      overflow-y: auto;   /* scroll long comments instead */
      max-height: 250px;  /* prevents pushing table down */
    }


    :root {
      --bg: #ffffff;
      --fg: #222222;
      --panel-bg: #ffffff;
      --panel-border: #dddddd;
      --workspace-border: #bbbbbb;
      --domino-bg: #ffffff;
      --domino-shadow: rgba(0,0,0,0.1);
      --status-ok: #333333;
      --status-err: darkred;
      --small-note: #555555;
    }

    body.dark-mode {
      --bg: #101215;
      --fg: #e5e7eb;
      --panel-bg: #111827;
      --panel-border: #374151;
      --workspace-border: #4b5563;
      --domino-bg: #1f2937;
      --domino-shadow: rgba(0,0,0,0.6);
      --status-ok: #e5e7eb;
      --status-err: #fca5a5;
      --small-note: #9ca3af;
    }

    body {
      font-family: system-ui, sans-serif;
      margin: 1.5rem;
      background: var(--bg);
      color: var(--fg);
      transition: background 0.2s ease, color 0.2s ease;
    }

    h1 {
      font-size: 1.4rem;
      margin-bottom: 0.5rem;
    }
    .row {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    label {
      font-weight: 600;
    }
    input[type="text"] {
      padding: 0.25rem 0.5rem;
      min-width: 12rem;
      background: var(--panel-bg);
      color: var(--fg);
      border: 1px solid var(--panel-border);
      border-radius: 0.25rem;
    }
    input[type="file"] {
      color: var(--fg);
    }
    button {
      padding: 0.4rem 0.8rem;
      border-radius: 0.4rem;
      border: 1px solid #ccc;
      cursor: pointer;
      background: var(--panel-bg);
      color: var(--fg);
    }
    button:hover {
      background: #f3f3f3;
    }
    body.dark-mode button:hover {
      background: #1f2937;
    }

    #tmInfo, #status {
      font-size: 0.9rem;
      margin-top: 0.5rem;
      white-space: pre-wrap;
    }

    .container {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
    }

    /* Split layout with draggable divider */
    .split-container {
      display: flex;
      gap: 0;
      margin-top: 1rem;
      min-height: 220px;
    }

    /* Left & right panels will be flex children of the splitter */
    #leftPane,
    #rightPane {
      min-width: 200px; /* prevent collapsing too much */
    }

    /* Vertical divider between palette and workspace */
    .divider {
      width: 5px;
      cursor: col-resize;
      background: var(--panel-border);
      flex: 0 0 auto;
    }

    body.dark-mode .divider {
      background: #4b5563;
    }


    .panel {
      flex: 1 1 320px;
      border: 1px solid var(--panel-border);
      border-radius: 0.5rem;
      padding: 0.75rem;
      min-height: 200px;
      background: var(--panel-bg);
      transition: background 0.2s ease, border-color 0.2s ease;
    }

    .panel h2 {
      font-size: 1.0rem;
      margin-top: 0;
    }

    .domino-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      max-height: 400px;
      overflow-y: auto;
    }

    .step-group {
      margin-bottom: 0.75rem;
    }

    .step-header {
      font-size: 0.85rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .domino {
      border: 1px solid #aaa;
      border-radius: 0.4rem;
      padding: 0.25rem 0.4rem;
      width: 90px;
      font-size: 0.75rem;
      background: var(--domino-bg);
      box-shadow: 1px 1px 2px var(--domino-shadow);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      cursor: grab;
      position: relative;
      transition: background 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      color: var(--fg);
    }

    .domino-top, .domino-bottom {
      text-align: center;
      padding: 0.1rem 0.15rem;
      border-radius: 0.2rem;
    }

    .domino-top {
      border-bottom: 1px solid #ccc;
      background: #f8f8f8;
    }

    body.dark-mode .domino-top {
      background: #111827;
      border-bottom-color: #4b5563;
    }

    .domino-bottom {
      background: #fdfdfd;
    }

    body.dark-mode .domino-bottom {
      background: #1f2937;
    }

    #workspace {
      min-height: 160px;
      border: 2px dashed var(--workspace-border);
      border-radius: 0.5rem;
      padding: 0.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    #workspace.dragover {
      border-color: #4a90e2;
      background: #f5f9ff;
    }
    body.dark-mode #workspace.dragover {
      background: #111827;
    }

    #concatStrings {
      margin-top: 0.75rem;
      font-family: monospace;
      font-size: 0.9rem;
      white-space: pre-wrap;
    }

    .equal {
      color: #22c55e;
      font-weight: bold;
    }
    .not-equal {
      color: #f97373;
      font-weight: bold;
    }

    .small-note {
      font-size: 0.8rem;
      color: var(--small-note);
      margin-top: 0.25rem;
    }

    .delete-btn {
      position: absolute;
      top: -0.45rem;
      right: -0.45rem;
      border-radius: 50%;
      border: 1px solid #ccc;
      width: 16px;
      height: 16px;
      padding: 0;
      font-size: 0.7rem;
      line-height: 14px;
      text-align: center;
      background: #f5f5f5;
      cursor: pointer;
      color: #111827;
    }
    .delete-btn:hover {
      background: #e6e6e6;
    }

    /* Color coding per step */
    .domino.step-1 { border-color: #1f77b4; }
    .domino.step-1 .domino-top { background: #e8f1fb; }
    body.dark-mode .domino.step-1 .domino-top { background: #1d3552; }

    .domino.step-2 { border-color: #ff7f0e; }
    .domino.step-2 .domino-top { background: #ffe9d5; }
    body.dark-mode .domino.step-2 .domino-top { background: #4b2a12; }

    .domino.step-3 { border-color: #2ca02c; }
    .domino.step-3 .domino-top { background: #e4f4e4; }
    body.dark-mode .domino.step-3 .domino-top { background: #1e3b20; }

    .domino.step-4 { border-color: #d62728; }
    .domino.step-4 .domino-top { background: #fbe4e4; }
    body.dark-mode .domino.step-4 .domino-top { background: #4b1516; }

    .domino.step-5 { border-color: #9467bd; }
    .domino.step-5 .domino-top { background: #efe6fb; }
    body.dark-mode .domino.step-5 .domino-top { background: #312151; }

    .domino.step-6 { border-color: #8c564b; }
    .domino.step-6 .domino-top { background: #f3e9e6; }
    body.dark-mode .domino.step-6 .domino-top { background: #42221b; }

    .domino.step-7 { border-color: #17becf; }
    .domino.step-7 .domino-top { background: #e5f6f8; }
    body.dark-mode .domino.step-7 .domino-top { background: #10434a; }

    .domino.step-8 { border-color: #555; }
    .domino.step-8 .domino-top { background: #eeeeee; }
    body.dark-mode .domino.step-8 .domino-top { background: #374151; }

    /* Text colors for concatenated strings */
    .step-text-1 { color: #1f77b4; }
    .step-text-2 { color: #ff7f0e; }
    .step-text-3 { color: #2ca02c; }
    .step-text-4 { color: #d62728; }
    .step-text-5 { color: #9467bd; }
    .step-text-6 { color: #f59e0b; }
    .step-text-7 { color: #17becf; }
    .step-text-8 { color: #9ca3af; }
  </style>
</head>
<body>

<h1>TM → PCP Domino Generator</h1>

<div style="margin: 0.6rem 0 1.2rem 0; font-size:0.85rem; line-height:1.35;">
  <strong>Developed by:</strong> Prof. Bruno Iochins Grisci<br>
  <em>(Webtool built using Generative AI — ChatGPT&nbsp;5.1)</em><br>
  Departamento de Informática Teórica —
  <a href="https://www.inf.ufrgs.br/site/" target="_blank">Instituto de Informática</a><br>
  <a href="https://www.ufrgs.br/site/" target="_blank">Universidade Federal do Rio Grande do Sul (UFRGS)</a><br>
  Website: <a href="https://brunogrisci.github.io/" target="_blank">https://brunogrisci.github.io/</a>
  <br><br>
  <strong>Based and inspired by the class of Prof. Rodrigo Machado:</strong><br>
  <a href="https://link.inf.ufrgs.br/212-AALr"
     target="_blank">
     https://link.inf.ufrgs.br/212-AALr
  </a>
</div>

<div style="margin: 0.6rem 0 1.2rem 0; font-size:0.85rem; line-height:1.35;">
  <strong>Input format:</strong><br>
  This webtool accepts a <code>.mt</code> file describing a Turing Machine created using the
  <strong>Simulador de Máquina de Turing</strong> developed by Prof. Rodrigo Machado:<br>
  <a href="https://link.inf.ufrgs.br/213-EIJy" target="_blank">
    https://link.inf.ufrgs.br/213-EIJy
  </a><br>
  The <code>.mt</code> file encodes the input &amp; auxiliary alphabet, states, transitions, marker and blank symbols.
</div>

<div class="row">
  <div>
    <label for="mtFile">.mt file: </label>
    <input type="file" id="mtFile" accept=".mt">
  </div>
  <div>
    <label for="inputWord">Input word w: </label>
    <input type="text" id="inputWord" placeholder="e.g., ()">
  </div>
  <div>
    <button id="generateBtn">Generate dominoes</button>
  </div>
  <div style="display:flex; align-items:center; gap:0.6rem; margin-left:auto;">
    <label style="font-weight:400; cursor:pointer;">
      <input type="checkbox" id="toggleMPCP">
      MPCP ⇒ PCP
    </label>
    <label style="font-weight:400; cursor:pointer;">
      <input type="checkbox" id="darkModeToggle">
      Dark mode
    </label>
  </div>
</div>

<div class="tm-summary">
  <div id="tmInfo"></div>

  <div id="tmTableContainer">
    <div id="tmTableLabel">Transition Table (δ)</div>
    <div id="tmTable"></div>
  </div>
</div>

<div id="status"></div>


<div class="split-container">
  <div id="leftPane" class="panel">
    <h2>Domino palette</h2>
    <div class="small-note">
      Dominoes are grouped and color-coded by construction step.<br>
      When “MPCP ⇒ PCP” is checked, you see the PCP instance, but still separated by their original steps.
    </div>
    <div id="dominoPalette"></div>
  </div>

  <div id="divider" class="divider" title="Drag to resize"></div>

  <div id="rightPane" class="panel">
    <h2>Workspace (sequence of dominoes)</h2>
    <div class="small-note">
      Drop tiles here in order. You can reorder or delete individual tiles.<br>
      The Top/Bottom strings below are color-coded according to the step each symbol came from.
    </div>
    <div id="workspace"></div>
    <button id="clearWorkspaceBtn" style="margin-top:0.5rem;">Clear workspace</button>
    <div id="concatStrings"></div>
  </div>
</div>


<script>
  // Global state
  let currentTM = null;
  let mpcpDominoes = [];
  let currentDominoes = [];

  function escapeHtml(str) {
    return String(str)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");
  }


  // Set current year in footer
  (function () {
    const el = document.getElementById('footer-year');
    if (!el) return;

    let year = 2025;  // fallback

    try {
      const d = new Date();
      const y = d.getFullYear();
      if (typeof y === "number" && !isNaN(y) && y > 1900 && y < 3000) {
        year = y;
      }
    } catch (e) {
      // silently fall back to 2025
    }

    el.textContent = year;
  })();



  // ----- Dark mode handling -----
  function applyDarkModeFromStorage() {
    const saved = localStorage.getItem('tm2pcp-dark-mode');
    const isDark = saved === 'true';
    document.body.classList.toggle('dark-mode', isDark);
    const chk = document.getElementById('darkModeToggle');
    if (chk) chk.checked = isDark;
  }

  function toggleDarkMode(enabled) {
    document.body.classList.toggle('dark-mode', enabled);
    localStorage.setItem('tm2pcp-dark-mode', enabled ? 'true' : 'false');
  }

  function showStatus(msg, isError=false) {
    const st = document.getElementById('status');
    st.textContent = msg || '';
    const dark = document.body.classList.contains('dark-mode');
    if (isError) {
      st.style.color = dark ? '#fca5a5' : 'darkred';
    } else {
      st.style.color = dark ? '#e5e7eb' : '#333333';
    }
  }

  // ----- Parsing the .mt file -----
  function parseMt(content) {
    const rawLines = content.split(/\r?\n/);

    if (rawLines.length < 7) {
      throw new Error(
        "Unexpected .mt format: need at least 7 lines " +
        "(alphabet, aux alphabet, marker, blank, states, initial, accepting)."
      );
    }

    const line = (idx) =>
      idx < rawLines.length ? rawLines[idx].trim() : "";

    const inputAlphabetLine = line(0);
    const auxAlphabetLine   = line(1);
    const markerSymbol      = line(2);
    const blankSymbol       = line(3);
    const statesLine        = line(4);
    const initialState      = line(5);
    const acceptStatesLine  = line(6);
    const transitionsLine   = line(7);

    const commentBlock = rawLines.slice(8).join("\n").trim();

    const parseCSV = (line) =>
      line
        .split(",")
        .map((s) => s.trim())
        .filter((s) => s.length > 0);

    const inputAlphabet = parseCSV(inputAlphabetLine);
    const auxAlphabet   = parseCSV(auxAlphabetLine);
    const states        = parseCSV(statesLine);
    const acceptStates  = parseCSV(acceptStatesLine);

    const tapeAlphabet = Array.from(new Set([...inputAlphabet, ...auxAlphabet]));

    const transitions = [];
    if (transitionsLine && transitionsLine.trim().length > 0) {
      const parts = transitionsLine
        .split(",,,")
        .map((s) => s.trim())
        .filter((s) => s.length > 0);

      for (const part of parts) {
        const f = part.split(",").map((s) => s.trim());
        if (f.length < 5) continue;
        let q, a, q2, b, dir;
        if (f.length === 6 && f[2] === "") {
          [q, a, , q2, b, dir] = f;
        } else if (f.length === 5) {
          [q, a, q2, b, dir] = f;
        } else {
          q   = f[0];
          a   = f[1];
          q2  = f[f.length - 3];
          b   = f[f.length - 2];
          dir = f[f.length - 1];
        }
        transitions.push({ q, a, q2, b, dir });
      }
    }

    return {
      inputAlphabet,
      auxAlphabet,
      alphabet: tapeAlphabet,
      markerSymbol,
      blankSymbol,
      states,
      initialState,
      acceptStates,
      transitions,
      comment: commentBlock
    };
  }

  function tokenizeWord(w) {
    return w.split("").filter(ch => ch !== " ");
  }

  function buildSymbolSet(tm, inputTokens) {
    const S = new Set();
    for (const a of tm.alphabet) S.add(a);
    S.add(tm.markerSymbol);
    S.add(tm.blankSymbol);
    for (const tr of tm.transitions) {
      if (tr.a) S.add(tr.a);
      if (tr.b) S.add(tr.b);
    }
    for (const t of inputTokens) S.add(t);
    return Array.from(S);
  }

  function chooseFreshSymbol(preferred, used) {
    const candidates = [
      preferred,
      "⋆", "☆", "@", "§", "+", "◊", "◆", "◇"
    ];
    for (const c of candidates) {
      if (!used.has(c)) return c;
    }
    let i = 1;
    while (used.has(preferred + i)) i++;
    return preferred + i;
  }

  // Domino: { top: [tokens], bottom: [tokens], info: string, step: 1..8 }
  function buildDominoes(tm, inputWord) {
    const wTokens = tokenizeWord(inputWord);

    const baseSymbols = buildSymbolSet(tm, wTokens);

    const usedForHash = new Set(baseSymbols);
    const HASH = chooseFreshSymbol("#", usedForHash);

    const S = baseSymbols;
    const q0 = tm.initialState;
    const acceptStates = tm.acceptStates || [];

    const dominos = [];

    function addDomino(topTokens, bottomTokens, info, step) {
      dominos.push({
        top: topTokens.slice(),
        bottom: bottomTokens.slice(),
        info: info || "",
        step: step
      });
    }

    // 1) Initial piece
    addDomino(
      [HASH],
      [HASH, q0, tm.markerSymbol, ...wTokens, HASH],
      "Step 1: initial configuration",
      1
    );

    // 2) Right moves
    for (const tr of tm.transitions) {
      const {q, a, q2, b, dir} = tr;
      if (!a || !b || !q || !q2) continue;
      if (acceptStates.includes(q)) continue;
      if (dir === "D") {
        addDomino(
          [q, a],
          [b, q2],
          "Step 2: right move " + q + "," + a + " → (" + q2 + "," + b + ",D)",
          2
        );
      }
    }

    // 3) Left moves
    for (const tr of tm.transitions) {
      const {q, a, q2, b, dir} = tr;
      if (!a || !b || !q || !q2) continue;
      if (acceptStates.includes(q)) continue;
      if (dir === "E") {
        for (const c of S) {
          addDomino(
            [c, q, a],
            [q2, c, b],
            "Step 3: left move " + q + "," + a + " → (" + q2 + "," + b + ",E)",
            3
          );
        }
      }
    }

    // 4) Copying tiles
    for (const a of S) {
      addDomino(
        [a],
        [a],
        "Step 4: copy symbol " + a,
        4
      );
    }

    // 5) #/# and #/β#
    addDomino([HASH], [HASH], "Step 5: boundary #/#", 5);
    addDomino([HASH], [tm.blankSymbol, HASH], "Step 5: boundary #/β#", 5);

    // 6) a q_f / q_f and q_f a / q_f for each accepting state
    for (const qf of acceptStates) {
      for (const a of S) {
        addDomino([a, qf], [qf], "Step 6: collapse a " + qf + " → " + qf, 6);
        addDomino([qf, a], [qf], "Step 6: collapse " + qf + " a → " + qf, 6);
      }
    }

    // 7) q_f ## / # for each accepting state
    for (const qf of acceptStates) {
      addDomino(
        [qf, HASH, HASH],
        [HASH],
        "Step 7: final cleanup " + qf + "##/#",
        7
      );
    }

    return dominos;
  }

  function renderTMInfo(tm) {
    const div = document.getElementById('tmInfo');
    if (!tm) {
      div.textContent = "";
      renderTransitionTable(null);
      return;
    }

    let text =
      "Parsed Turing Machine:\n" +
      "  Input alphabet (Σ): " + tm.inputAlphabet.join(", ") + "\n" +
      "  Auxiliary alphabet (Γ \\ Σ): " +
        (tm.auxAlphabet && tm.auxAlphabet.length
           ? tm.auxAlphabet.join(", ")
           : "∅") + "\n" +
      "  Tape alphabet (Σ ∪ Γ): " + tm.alphabet.join(", ") + "\n" +
      "  Marker (beg. of tape): " + tm.markerSymbol + "\n" +
      "  Blank (β): " + tm.blankSymbol + "\n" +
      "  States (Q): " + tm.states.join(", ") + "\n" +
      "  Initial state (q0): " + tm.initialState + "\n" +
      "  Accepting states (F): " +
        (tm.acceptStates && tm.acceptStates.length
           ? tm.acceptStates.join(", ")
           : "∅") + "\n" +
      "  #Transitions: " + tm.transitions.length;

    if (tm.comment && tm.comment.trim().length > 0) {
      text += "\n\nComment (from .mt file):\n" + tm.comment;
    }

    div.textContent = text;

    // NEW: render transition table to the right
    renderTransitionTable(tm);
  }


  function renderTransitionTable(tm) {
    const container = document.getElementById('tmTable');
    if (!container) return;

    if (!tm) {
      container.innerHTML = "";
      return;
    }

    // Tape symbols = alphabet ∪ {marker, blank}
    const tapeSymbols = Array.from(new Set([
      ...tm.alphabet,
      tm.markerSymbol,
      tm.blankSymbol
    ]));

    const initial = tm.initialState;
    const acceptSet = new Set(tm.acceptStates || []);

    // Order: initial state first, then others, then accepting states at the end
    const others = tm.states.filter(
      s => s !== initial && !acceptSet.has(s)
    );
    const accepts = tm.states.filter(
      s => acceptSet.has(s) && s !== initial
    );

    const rowStates = [];
    if (initial) rowStates.push(initial);
    rowStates.push(...others);
    rowStates.push(...accepts);

    // Map (q,a) -> transition
    const transMap = new Map();
    for (const tr of tm.transitions) {
      if (!tr.q || tr.a == null) continue;
      const key = tr.q + "||" + tr.a;
      if (!transMap.has(key)) {
        transMap.set(key, tr);
      }
    }

    let html = '<table class="tm-table"><thead><tr>';
    html += '<th>q / a</th>';
    for (const a of tapeSymbols) {
      html += `<th>${escapeHtml(a)}</th>`;
    }
    html += '</tr></thead><tbody>';

    for (const q of rowStates) {
      const isInit = (q === initial);
      const isAcc  = acceptSet.has(q);

      let label = q;
      if (isInit && isAcc) label = '→★ ' + q;
      else if (isInit)     label = '→ '  + q;
      else if (isAcc)      label = '★ '  + q;

      let stateClass = "tm-state-cell";
      if (isInit)  stateClass += " tm-state-cell-init";
      if (isAcc)   stateClass += " tm-state-cell-accept";

      html += `<tr><th class="${stateClass}">${escapeHtml(label)}</th>`;

      for (const a of tapeSymbols) {
        const key = q + "||" + a;
        const tr = transMap.get(key);
        if (tr) {
          const cell = `${tr.q2},${tr.b},${tr.dir}`;
          html += `<td>${escapeHtml(cell)}</td>`;
        } else {
          html += '<td>–</td>';
        }
      }
      html += '</tr>';
    }

    html += '</tbody></table>';
    container.innerHTML = html;
  }


  function tokensToDisplay(tokens) {
    return tokens.join(" ");
  }

  function renderDominoPalette(dominos) {
    const palette = document.getElementById('dominoPalette');
    palette.innerHTML = "";

    const steps = Array.from(new Set(dominos.map(d => d.step))).sort((a, b) => a - b);
    const usePCP = document.getElementById('toggleMPCP')?.checked;

    steps.forEach(step => {
      const groupDominos = dominos.filter(d => d.step === step);
      if (groupDominos.length === 0) return;

      const group = document.createElement('div');
      group.className = 'step-group';

      const header = document.createElement('div');
      header.className = 'step-header';

      if (step === 8) {
        header.textContent = "Step 8 (closing tile for MPCP ⇒ PCP)";
      } else if (usePCP) {
        header.textContent = "Step " + step + " (PCP, from original Step " + step + ")";
      } else {
        header.textContent = "Step " + step;
      }

      group.appendChild(header);

      const list = document.createElement('div');
      list.className = 'domino-list';

      for (let i = 0; i < dominos.length; i++) {
        const d = dominos[i];
        if (d.step !== step) continue;

        const el = document.createElement('div');
        el.className = 'domino step-' + step;
        el.draggable = true;
        el.dataset.dominoIndex = String(i);
        el.title = d.info;

        const top = document.createElement('div');
        top.className = 'domino-top';
        top.textContent = tokensToDisplay(d.top);

        const bottom = document.createElement('div');
        bottom.className = 'domino-bottom';
        bottom.textContent = tokensToDisplay(d.bottom);

        el.appendChild(top);
        el.appendChild(bottom);

        el.addEventListener('dragstart', (ev) => {
          ev.dataTransfer.setData('text/plain', 'palette:' + String(i));
        });

        list.appendChild(el);
      }

      group.appendChild(list);
      palette.appendChild(group);
    });
  }

  function createWorkspaceTile(idx, fixed = false) {
    const workspace = document.getElementById('workspace');
    const d = currentDominoes[idx];

    const tile = document.createElement('div');
    tile.className = 'domino step-' + d.step;
    tile.dataset.dominoIndex = String(idx);
    tile.title = d.info;

    const top = document.createElement('div');
    top.className = 'domino-top';
    top.textContent = tokensToDisplay(d.top);

    const bottom = document.createElement('div');
    bottom.className = 'domino-bottom';
    bottom.textContent = tokensToDisplay(d.bottom);

    tile.appendChild(top);
    tile.appendChild(bottom);

    if (fixed) {
      // Fixed initial MPCP tile: cannot be moved or deleted
      tile.dataset.fixed = "true";
      tile.draggable = false;
    } else {
      tile.draggable = true;

      const delBtn = document.createElement('button');
      delBtn.className = 'delete-btn';
      delBtn.textContent = '×';
      delBtn.title = 'Remove this tile';

      delBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        tile.remove();
        concatWorkspaceStrings();
      });

      tile.appendChild(delBtn);

      tile.addEventListener('dragstart', (ev) => {
        const children = Array.from(workspace.children);
        const fromIndex = children.indexOf(tile);
        ev.dataTransfer.setData('text/plain', 'workspace:' + fromIndex);
      });
    }

    return tile;
  }


  function concatWorkspaceStrings() {
    const workspace = document.getElementById('workspace');
    const children = Array.from(workspace.querySelectorAll('.domino'));

    const topSeq = [];
    const bottomSeq = [];

    for (const ch of children) {
      const idx = parseInt(ch.dataset.dominoIndex, 10);
      const d = currentDominoes[idx];
      const step = d.step;
      for (const sym of d.top) {
        topSeq.push({ sym, step });
      }
      for (const sym of d.bottom) {
        bottomSeq.push({ sym, step });
      }
    }

    const concatDiv = document.getElementById('concatStrings');
    if (children.length === 0) {
      concatDiv.textContent = "";
      return;
    }

    function seqToHTML(seq) {
      return seq.map(t => {
        const cls = `step-text-${t.step}`;
        const safeSym = String(t.sym)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
        return `<span class="${cls}">${safeSym}</span>`;
      }).join(" ");
    }

    const topHTML = seqToHTML(topSeq);
    const bottomHTML = seqToHTML(bottomSeq);

    const equal = topSeq.map(t => t.sym).join("|") === bottomSeq.map(t => t.sym).join("|");

    concatDiv.innerHTML =
      `Top:    ${topHTML}<br>` +
      `Bottom: ${bottomHTML}<br><br>` +
      (equal
        ? "<span class='equal'>Top and bottom are equal ✔</span>"
        : "<span class='not-equal'>Top and bottom differ ✘</span>");
  }

  function setupWorkspaceDnD() {
    const workspace = document.getElementById('workspace');

    workspace.addEventListener('dragover', (ev) => {
      ev.preventDefault();
      workspace.classList.add('dragover');
    });

    workspace.addEventListener('dragleave', () => {
      workspace.classList.remove('dragover');
    });

    workspace.addEventListener('drop', (ev) => {
      ev.preventDefault();
      workspace.classList.remove('dragover');

      const data = ev.dataTransfer.getData('text/plain');
      if (!data) return;
      const [src, idxStr] = data.split(':');
      const workspaceChildren = Array.from(workspace.children);

      let targetTile = ev.target.closest('.domino');
      if (targetTile && targetTile.parentElement !== workspace) {
        targetTile = null;
      }

      if (src === 'palette') {
        const idx = parseInt(idxStr, 10);
        if (isNaN(idx)) return;
        const newTile = createWorkspaceTile(idx);

        if (!targetTile) {
          workspace.appendChild(newTile);
        } else {
          const rect = targetTile.getBoundingClientRect();
          let before = ev.clientX < rect.left + rect.width / 2;

          // If target is fixed and we would insert BEFORE it, force AFTER
          if (targetTile.dataset.fixed === "true" && before) {
            before = false;
          }

          if (before) {
            workspace.insertBefore(newTile, targetTile);
          } else {
            workspace.insertBefore(newTile, targetTile.nextSibling);
          }
        }
      } else if (src === 'workspace') {
        const fromIndex = parseInt(idxStr, 10);
        if (isNaN(fromIndex)) return;
        const dragged = workspaceChildren[fromIndex];
        if (!dragged) return;

        if (!targetTile || targetTile === dragged) {
          workspace.appendChild(dragged);
        } else {
          const rect = targetTile.getBoundingClientRect();
          let before = ev.clientX < rect.left + rect.width / 2;

          // Never insert before fixed tile
          if (targetTile.dataset.fixed === "true" && before) {
            before = false;
          }

          if (before) {
            workspace.insertBefore(dragged, targetTile);
          } else {
            workspace.insertBefore(dragged, targetTile.nextSibling);
          }
        }
      }


      concatWorkspaceStrings();
    });
  }

  function setupSplitter() {
    const container = document.querySelector('.split-container');
    const leftPane = document.getElementById('leftPane');
    const rightPane = document.getElementById('rightPane');
    const divider = document.getElementById('divider');

    if (!container || !leftPane || !rightPane || !divider) return;

    let isDragging = false;

    divider.addEventListener('mousedown', (e) => {
      e.preventDefault();
      isDragging = true;
      document.body.style.userSelect = 'none';
    });

    window.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        document.body.style.userSelect = '';
      }
    });

    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const rect = container.getBoundingClientRect();
      let offsetX = e.clientX - rect.left;

      // clamp: leave at least 200px for each panel
      const min = 200;
      const max = rect.width - 200;
      if (offsetX < min) offsetX = min;
      if (offsetX > max) offsetX = max;

      const leftPercent = (offsetX / rect.width) * 100;
      const rightPercent = 100 - leftPercent;

      leftPane.style.flex = `0 0 ${leftPercent}%`;
      rightPane.style.flex = `0 0 ${rightPercent}%`;
    });
  }


  // ----- MPCP → PCP transformation -----

  function computeUsedSymbols(dominos) {
    const used = new Set();
    for (const d of dominos) {
      for (const t of d.top) used.add(t);
      for (const t of d.bottom) used.add(t);
    }
    return used;
  }

  function starPrefix(seq, star) {
    const res = [];
    for (const s of seq) {
      res.push(star, s);
    }
    return res;
  }

  function starSuffix(seq, star) {
    const res = [];
    for (const s of seq) {
      res.push(s, star);
    }
    return res;
  }

  function starBoth(seq, star) {
    const res = [star];
    for (const s of seq) {
      res.push(s, star);
    }
    return res;
  }

  function transformMPCPtoPCP(mpcpDominoes) {
    if (!mpcpDominoes || mpcpDominoes.length === 0) return [];

    const used = computeUsedSymbols(mpcpDominoes);
    const starSym = chooseFreshSymbol("*", used);
    used.add(starSym);
    const diamondSym = chooseFreshSymbol("⋄", used);

    const PCP = [];

    const first = mpcpDominoes[0];
    const t1 = first.top;
    const b1 = first.bottom;
    const s1 = first.step;

    PCP.push({
      top: starPrefix(t1, starSym),
      bottom: starBoth(b1, starSym),
      info: "PCP (from Step " + s1 + "): forcing first tile (⋆t₁ / ⋆b₁⋆)",
      step: s1
    });

    PCP.push({
      top: starPrefix(t1, starSym),
      bottom: starSuffix(b1, starSym),
      info: "PCP (from Step " + s1 + "): continuation (⋆t₁ / b₁⋆)",
      step: s1
    });

    for (let i = 1; i < mpcpDominoes.length; i++) {
      const d = mpcpDominoes[i];
      PCP.push({
        top: starPrefix(d.top, starSym),
        bottom: starSuffix(d.bottom, starSym),
        info: "PCP (from Step " + d.step + "): tile from MPCP index " + (i + 1),
        step: d.step
      });
    }

    PCP.push({
      top: [starSym, diamondSym],
      bottom: [diamondSym],
      info: "PCP: closing tile " + starSym + diamondSym + "/" + diamondSym,
      step: 8
    });

    return PCP;
  }

  function updateDominoView() {
    const toggle = document.getElementById('toggleMPCP');
    const usePCP = toggle && toggle.checked;

    if (!mpcpDominoes || mpcpDominoes.length === 0) {
      currentDominoes = [];
      renderDominoPalette([]);
      document.getElementById('workspace').innerHTML = "";
      concatWorkspaceStrings();
      showStatus("No MPCP dominoes to display.");
      return;
    }

    const N = mpcpDominoes.length;

    if (usePCP) {
      currentDominoes = transformMPCPtoPCP(mpcpDominoes);
      const K = currentDominoes.length;
      showStatus(
        "Showing PCP instance with " + K + " dominoes " +
        "(derived from " + N + " MPCP dominoes)."
      );
    } else {
      currentDominoes = mpcpDominoes.slice();
      showStatus("Showing original " + N + " MPCP dominoes.");
    }

  renderDominoPalette(currentDominoes);

  const workspace = document.getElementById('workspace');
  workspace.innerHTML = "";

  if (usePCP) {
    // PCP: workspace starts empty
    concatWorkspaceStrings();
  } else {
    // MPCP: place the first domino (step 1) as a fixed, non-removable, first tile
    if (currentDominoes.length > 0) {
      const fixedTile = createWorkspaceTile(0, true);
      workspace.appendChild(fixedTile);
    }
    concatWorkspaceStrings();
  }
}


  // ----- Wiring UI events -----

  document.getElementById('mtFile').addEventListener('change', (ev) => {
    const file = ev.target.files[0];
    if (!file) {
      currentTM = null;
      mpcpDominoes = [];
      currentDominoes = [];
      renderTMInfo(null);
      renderDominoPalette([]);
      document.getElementById('workspace').innerHTML = "";
      concatWorkspaceStrings();
      showStatus("");
      return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        currentTM = parseMt(e.target.result);
        renderTMInfo(currentTM);
        showStatus("Turing machine parsed successfully.");
      } catch (err) {
        console.error(err);
        showStatus("Error parsing .mt file: " + err.message, true);
        currentTM = null;
        renderTMInfo(null);
      }
    };
    reader.readAsText(file);
  });

  document.getElementById('generateBtn').addEventListener('click', () => {
    if (!currentTM) {
      showStatus("Please load a .mt file first.", true);
      return;
    }
    const w = document.getElementById('inputWord').value || "";
    try {
      mpcpDominoes = buildDominoes(currentTM, w);
      updateDominoView();
    } catch (err) {
      console.error(err);
      showStatus("Error generating dominoes: " + err.message, true);
    }
  });

  document.getElementById('clearWorkspaceBtn').addEventListener('click', () => {
    const workspace = document.getElementById('workspace');
    const usePCP = document.getElementById('toggleMPCP')?.checked;

    if (usePCP) {
      // PCP: clear everything
      workspace.innerHTML = "";
    } else {
      // MPCP: keep the fixed first tile (if any), remove the rest
      const children = Array.from(workspace.children);
      const fixed = children.find(ch => ch.dataset && ch.dataset.fixed === "true");
      workspace.innerHTML = "";
      if (fixed) {
        workspace.appendChild(fixed);
      }
    }
    concatWorkspaceStrings();
  });


  document.getElementById('toggleMPCP').addEventListener('change', () => {
    if (!mpcpDominoes || mpcpDominoes.length === 0) {
      return;
    }
    updateDominoView();
  });

  document.getElementById('darkModeToggle').addEventListener('change', (e) => {
    toggleDarkMode(e.target.checked);
    // Repaint status color for current mode
    const st = document.getElementById('status').textContent;
    if (st) showStatus(st);
  });

  setupWorkspaceDnD();
  applyDarkModeFromStorage();
  setupSplitter();

</script>

  <footer class="app-footer">
    <div class="footer-inner">
      <div>
        © <span id="footer-year"></span>
        <a href="https://brunogrisci.github.io/" target="_blank">Prof. Bruno Iochins Grisci</a>
        — Departamento de Informática Teórica,
        <a href="https://www.inf.ufrgs.br/site/" target="_blank">Instituto de Informática</a>,
        <a href="https://www.ufrgs.br/site/" target="_blank">UFRGS</a>.
      </div>
      <div>
        Code on GitHub:
        <a href="https://github.com/BrunoGrisci/tm2pcp-webtool" target="_blank">
          brunogrisci/tm2pcp-webtool
        </a>
        — Licensed under
        <a href="https://github.com/brunogrisci/tm2pcp-webtool/blob/main/LICENSE" target="_blank">
          MIT License
        </a>.
      </div>
    </div>
  </footer>


</body>
</html>
